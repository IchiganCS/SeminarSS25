
\begin{abstract}

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}
\label{sec:introduction}

Distributed computing has emerged as a central strategy for providing large, scalable and complex services. To handle a large number of distributed nodes efficiently, specialized programming languages like Go, Erlang and Elixir were developed. These languages provide first class support for processes and messages exchanged between those.

There are several methods to design such a message passing system, with two variants being most prominent: A channel-based system like implemented in Go makes it possible for one process to store messages in a message queue and another process can read from that queue. Those are not discussed in report. Erlang and Elixir instead use a actor-based system where each process, called actor, is associated with a mailbox. Each mailbox can be populated from every process by sending a message and only the owner of the mailbox can read from that queue. The rules for reading are usually quite relaxed, with the possiblity for out-of-order processing.

In such systems, the sent messages must have several characteristics which must be maintained by the processes to ensure correctness: each message must be syntactically valid and also be only sent in a correct context. The syntactic correctness of a message is given when it adheres to a specific layout of data, like a pair of integers. Since usually different kinds of messages can be handled by processes, it is logical that the message passing systems discussed here differentiate messages by tags. A syntactically correct message has a specified tag and stores additionally exactly the information required by that tag. 

A contextually correct message respects the state of the receiving actor. An actor might want to restrict users to only send a message of a given kind a limited number of times or requires that a message of a given type is sent at some point. 


A very good example is a future variable process. That is a process for which a value is set exactly once and which then can provide a value on request to different nodes. Code for such a process is shown in listing \ref{lst:futureErlang}.


\begin{figure}[ht]
\begin{minipage}[c]{0.48\linewidth}
    \begin{lstlisting}
empty_future() ->
  receive
    { set, X } -> full_future(X)
  end.

full_future(X) ->
  receive
    { get, Pid } ->
      Pid ! { reply, X },
      full_future(X);
    { set, _ } ->
      erlang:error("Multiple writes")
  end.
    \end{lstlisting}
    \caption{Implementation of a future process in Erlang\cite{fowlerSpecialDeliveryProgramming2023}.}
    \label{lst:futureErlang}
\end{minipage}
\hfill
\begin{minipage}[c]{0.48\linewidth}
    \begin{tikzpicture}[node distance=3cm,on grid,auto]
        \node[text width=1.1cm,align=center,state,initial] (s0) {empty};
        \node[text width=1.1cm,align=center,state] (s1) [right of=s0] {full};
        \path[->]
        (s0) edge node {set} (s1)
        (s0) edge [loop above] node {get (delayed)} ()
        (s1) edge [loop above] node {get (reply)} ();
    \end{tikzpicture}
    \caption{State automaton of a future process. Get requests in the empty state are not answered immediately, but their response is delayed until a value is set. This works beacuse mailboxes typically provide out-of-order operation.}
    \label{fig:futureStateAutomaton}
\end{minipage}
\end{figure}

While syntactic checks, which guarantee that only ever correct get and set operations are sent to the future, are not overly complex and can be implemented rather easily, expressing this state automaton is much more interesting. 

While the code works, it can be used wrong: For multiple set operations, an error will be generated at runtime. The invariant that the set operation can only and must be exactly called once is not encoded. Additionally, a process using this future will have no guarantee that the future really does send a reply. A compiler could not check if the get operation of the consuming client erroneously precedes a set operation. Also, the compiler does not guarantee that the future process indeed sends a to the get operation.

All of these issues could be resolved if we could transform the automaton and the state of the process into the type system. In the following, it is explored how mailboxes can be typed using regular expressions of messages to achieve this. We will determine the mailbox type $?(Put[Int] \cdot Get[!Reply[Int]]^*)$ for the empty future mailbox which encodes all the guarantees required for safe execution.

The research questions we are thus interested to discuss are the following:
\begin{itemize}
    \item Present and explain mailbox typing as presented by Fowler et al.\cite{fowlerSpecialDeliveryProgramming2023}.
    \item Showcase advantages and shortcomings through case studies.
\end{itemize}


\section{Background}
\label{sec:background}

\subsection{Channel-based vs. actor-based message passing}


\subsection{Mailbox validity}


\subsection{Behavioral types}


\section{Topic-specific content}
\label{sec:contentSummary}

\subsection{Mailbox calculus}

\subsection{Pat}

\subsection{Theoretical limits}

\subsection{Performance implications}





\section{Discussion}
\label{sec:discussion}




\section{Conclusion}
\label{sec:conclusions}



